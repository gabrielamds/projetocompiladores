<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guia Completo - Compilador C-</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.7;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f2f5;
        }
        h1 {
            color: #1a1a1a;
            border-bottom: 4px solid #2196F3;
            padding-bottom: 15px;
            margin-bottom: 30px;
            text-align: center;
        }
        h2 {
            color: #1976D2;
            margin-top: 40px;
            margin-bottom: 20px;
            border-left: 5px solid #2196F3;
            padding-left: 15px;
            font-size: 1.5em;
        }
        h3 {
            color: #455A64;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        h4 {
            color: #546E7A;
            margin-top: 15px;
            margin-bottom: 10px;
        }
        .secao {
            background-color: white;
            padding: 25px;
            margin: 25px 0;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-top: 4px solid #2196F3;
        }
        code {
            background-color: #f5f5f5;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #d32f2f;
        }
        pre {
            background-color: #263238;
            color: #aed581;
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            border-left: 4px solid #2196F3;
            line-height: 1.5;
        }
        .exemplo {
            background-color: #e3f2fd;
            border-left: 5px solid #2196F3;
            border-radius: 4px;
            padding: 18px;
            margin: 18px 0;
        }
        .exemplo strong {
            color: #1565C0;
        }
        .teoria {
            background-color: #f3e5f5;
            border-left: 5px solid #7b1fa2;
            border-radius: 4px;
            padding: 18px;
            margin: 18px 0;
        }
        .teoria strong {
            color: #6a1b9a;
        }
        .importante {
            background-color: #fff8e1;
            border-left: 5px solid #f57f17;
            border-radius: 4px;
            padding: 18px;
            margin: 18px 0;
        }
        .importante strong {
            color: #e65100;
        }
        .arquivo {
            background-color: #e8f5e9;
            border-left: 5px solid #388e3c;
            border-radius: 4px;
            padding: 12px;
            margin: 15px 0;
            font-weight: bold;
            color: #1b5e20;
        }
        ul {
            line-height: 2;
        }
        li {
            margin-bottom: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        th, td {
            border: 1px solid #e0e0e0;
            padding: 14px;
            text-align: left;
        }
        th {
            background-color: #1976D2;
            color: white;
            font-weight: 600;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .nav {
            background-color: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border-left: 5px solid #2196F3;
        }
        .nav h3 {
            margin-top: 0;
            color: #1976D2;
        }
        .nav ol {
            line-height: 2;
        }
        .nav a {
            color: #2196F3;
            text-decoration: none;
        }
        .nav a:hover {
            text-decoration: underline;
        }
        .explicacao {
            background-color: #eceff1;
            border-left: 4px solid #0288d1;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>

<h1>üìö Guia Completo do Compilador C-</h1>

<div class="nav">
    <h3>üìë √çndice de Conte√∫do</h3>
    <ol>
        <li><a href="#teoria-basica">Teoria B√°sica de Compiladores</a></li>
        <li><a href="#analisador-lexico">Analisador L√©xico (cminus.l)</a></li>
        <li><a href="#tabela-simbolos">Tabela de S√≠mbolos (simbolos.h/c)</a></li>
        <li><a href="#analisador-sintatico">Analisador Sint√°tico (cminus.y)</a></li>
        <li><a href="#arvore-sintatica">√Årvore Sint√°tica (arvore.h/c)</a></li>
        <li><a href="#analisador-semantico">Analisador Sem√¢ntico (semantico.h/c)</a></li>
        <li><a href="#gerador-codigo">Gerador de C√≥digo Intermedi√°rio (intermediario.h/c)</a></li>
        <li><a href="#comandos">Comandos de Compila√ß√£o</a></li>
    </ol>
</div>

<div class="secao" id="teoria-basica">
    <h2>1. Teoria B√°sica de Compiladores</h2>
    
    <h3>O que √© um Compilador?</h3>
    <p>Um <strong>compilador</strong> √© um programa que traduz c√≥digo-fonte escrito em uma linguagem de programa√ß√£o de alto n√≠vel para uma representa√ß√£o de mais baixo n√≠vel (intermedi√°ria ou linguagem de m√°quina) que pode ser executada por um computador.</p>
    
    <div class="teoria">
        <strong>Processo de Compila√ß√£o:</strong><br><br>
        Um compilador funciona atrav√©s de v√°rias <strong>fases distintas</strong>. Cada fase recebe a sa√≠da da fase anterior e produz uma representa√ß√£o mais refinada do programa.
    </div>
    
    <h3>As 4 Fases Principais do Compilador C-</h3>
    
    <pre>
C√ìDIGO-FONTE (arquivo.cm)
        ‚Üì
        ‚ïë
        ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
        ‚ïë                                               ‚ïë
    [FASE 1]                                         [FASE 2]
   AN√ÅLISE L√âXICA                              AN√ÅLISE SINT√ÅTICA
   (Scanner/Lexer)                             (Parser)
   
   Entrada: caracteres                        Entrada: tokens
   Sa√≠da: tokens                              Sa√≠da: √°rvore sint√°tica
   Ferramenta: Flex (cminus.l)                Ferramenta: Bison (cminus.y)
        ‚ïë                                               ‚ïë
        ‚ïë                                               ‚ïë
        ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                            ‚Üì
                            
                    [FASE 3]
                AN√ÅLISE SEM√ÇNTICA
                    
                Entrada: √°rvore sint√°tica
                Sa√≠da: √°rvore validada + tabela de s√≠mbolos
                Arquivo: semantico.c
                
                Verifica√ß√µes:
                - Vari√°veis declaradas?
                - Tipos compat√≠veis?
                - main() existe?
                
                            ‚Üì
                            
                    [FASE 4]
            GERA√á√ÉO DE C√ìDIGO INTERMEDI√ÅRIO
            
                Entrada: √°rvore sint√°tica
                Sa√≠da: instru√ß√µes de 3 endere√ßos
                Arquivo: intermediario.c
                
                Formato: resultado = operando1 OP operando2
    </pre>
    
    <h3>Componentes Essenciais</h3>
    
    <div class="explicacao">
        <strong>Tokens:</strong> Unidades b√°sicas do c√≥digo. Exemplos: <code>int</code>, <code>x</code>, <code>5</code>, <code>+</code>, <code>;</code>
    </div>
    
    <div class="explicacao">
        <strong>√Årvore Sint√°tica (AST):</strong> Representa a estrutura hier√°rquica do programa. Mostra como os tokens se combinam para formar express√µes, comandos e fun√ß√µes.
    </div>
    
    <div class="explicacao">
        <strong>Tabela de S√≠mbolos:</strong> Banco de dados que mant√©m informa√ß√µes sobre todas as vari√°veis e fun√ß√µes: nome, tipo, escopo, linha de declara√ß√£o.
    </div>
    
    <div class="explicacao">
        <strong>C√≥digo Intermedi√°rio:</strong> Forma simplificada do programa que facilita otimiza√ß√µes e tradu√ß√£o para c√≥digo de m√°quina.
    </div>
</div>

<div class="secao" id="analisador-lexico">
    <h2>2. Analisador L√©xico (cminus.l)</h2>
    
    <div class="arquivo">Arquivo: cminus.l</div>
    
    <h3>O que faz?</h3>
    <p>L√™ o c√≥digo-fonte caractere por caractere e identifica <strong>tokens</strong> (palavras-chave, identificadores, n√∫meros, operadores).</p>
    
    <div class="teoria">
        <strong>Teoria da An√°lise L√©xica:</strong><br><br>
        A an√°lise l√©xica √© a <strong>primeira fase</strong> do compilador. Seu trabalho √© quebrar o c√≥digo-fonte em peda√ßos menores e reconhec√≠veis chamados <strong>tokens</strong>. Para isso, usa <strong>express√µes regulares</strong> para definir padr√µes.
        <br><br>
        <strong>Exemplo de Express√£o Regular:</strong><br>
        ‚Ä¢ <code>[0-9]+</code> = um ou mais d√≠gitos (n√∫meros inteiros)<br>
        ‚Ä¢ <code>[a-zA-Z][a-zA-Z0-9]*</code> = identificadores (vari√°veis)<br>
        ‚Ä¢ <code>"+"|"-"|"*"|"/"</code> = operadores aritm√©ticos<br>
        <br>
        O Flex l√™ essas regras e gera automaticamente um programa em C que reconhece esses padr√µes. Ele mant√©m um <strong>aut√¥mato finito</strong> (m√°quina de estados) internamente para reconhecer cada padr√£o.
    </div>
    
    <div class="exemplo">
        <strong>Exemplo:</strong><br>
        <strong>C√≥digo-fonte:</strong><br>
        <code>int x = 5;</code><br><br>
        
        <strong>Tokens gerados:</strong>
        <ul>
            <li><code>int</code> ‚Üí INT (palavra-chave)</li>
            <li><code>x</code> ‚Üí ID (identificador)</li>
            <li><code>=</code> ‚Üí ATRIBUICAO</li>
            <li><code>5</code> ‚Üí NUM (n√∫mero)</li>
            <li><code>;</code> ‚Üí PONTOVIRGULA</li>
        </ul>
    </div>
    
    <h3>Estrutura Detalhada do arquivo cminus.l:</h3>
    <pre>
%{
/* SE√á√ÉO 1: C√ìDIGO C - Declara√ß√µes e includes
   Este c√≥digo √© copiado diretamente para o lex.yy.c gerado */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "cminus.tab.h"  /* Headers gerados pelo Bison com defini√ß√µes de tokens */

int linha = 1;  /* Contador de linhas para mensagens de erro */

%}

/* SE√á√ÉO 2: DEFINI√á√ïES - Macros para facilitar a escrita das regras
   Aqui definimos abrevia√ß√µes para padr√µes que usaremos repetidamente */

DIGITO      [0-9]           /* Um d√≠gito de 0 a 9 */
LETRA       [a-zA-Z_]       /* Uma letra (mai√∫scula, min√∫scula ou underscore) */
ID          {LETRA}({LETRA}|{DIGITO})*    /* Identificadores: come√ßam com letra, depois letras ou d√≠gitos */
NUMERO      {DIGITO}+       /* N√∫meros inteiros: um ou mais d√≠gitos */

%%
/* SE√á√ÉO 3: REGRAS - Padr√µes e a√ß√µes
   Formato: padr√£o { c√≥digo C a executar quando padr√£o √© encontrado } */

/* PALAVRAS-CHAVE - Devem ser testadas ANTES dos identificadores gen√©ricos */
"if"        { return IF; }          /* Reconhece "if", retorna token IF */
"else"      { return ELSE; }        /* Reconhece "else", retorna token ELSE */
"while"     { return WHILE; }       /* Reconhece "while", retorna token WHILE */
"return"    { return RETURN; }      /* Reconhece "return", retorna token RETURN */
"int"       { return INT; }         /* Reconhece "int", retorna token INT */
"void"      { return VOID; }        /* Reconhece "void", retorna token VOID */

/* IDENTIFICADORES - Nomes de vari√°veis e fun√ß√µes
   Armazenamos o texto reconhecido em yylval.str para usar depois */
{ID}        { yylval.str = strdup(yytext);    /* yytext = texto reconhecido */
              return ID; }

/* N√öMEROS - Convertemos string para inteiro
   Armazenamos o valor em yylval.num */
{NUMERO}    { yylval.num = atoi(yytext);      /* atoi converte string para int */
              return NUM; }

/* OPERADORES ARITM√âTICOS */
"+"         { return MAIS; }
"-"         { return MENOS; }
"*"         { return VEZES; }
"/"         { return DIVIDIDO; }

/* OPERADOR DE ATRIBUI√á√ÉO */
"="         { return ATRIBUICAO; }

/* OPERADORES DE COMPARA√á√ÉO */
"=="        { return IGUAL; }
"!="        { return DIFERENTE; }
"&lt;"         { return MENOR; }
"&lt;="        { return MENOR_IGUAL; }
"&gt;"         { return MAIOR; }
"&gt;="        { return MAIOR_IGUAL; }

/* DELIMITADORES E PONTUA√á√ÉO */
";"         { return PONTOVIRGULA; }
"("         { return ABREPARENTESES; }
")"         { return FECHAPARENTESES; }
"{"         { return ABRECHAVE; }
"}"         { return FECHACHAVE; }
"["         { return ABRECOLCHETE; }
"]"         { return FECHACOLCHETE; }
","         { return VIRGULA; }

/* ESPA√áOS EM BRANCO - Ignoramos (n√£o geram tokens)
   √öteis para separar tokens mas sem significado l√©xico */
[ \t]+      { /* Ignora espa√ßos e tabula√ß√µes */ }

/* QUEBRA DE LINHA - Incrementa contador de linhas
   Importante para mensagens de erro com n√∫mero de linha correto */
\n          { linha++; }

/* CARACTERE DESCONHECIDO - Erro l√©xico
   . representa qualquer caractere que n√£o foi capturado pelas regras anteriores */
.           { printf("ERRO LEXICO: '%s' LINHA: %d\n", yytext, linha); }

%%

/* SE√á√ÉO 4: C√ìDIGO C - Fun√ß√µes auxiliares (opcionais)
   Neste projeto n√£o usamos, mas √© o lugar para colocar fun√ß√µes adicionais */
    </pre>
    
    <h3>Explica√ß√£o do Processo:</h3>
    <div class="explicacao">
        <strong>1. Leitura Sequencial:</strong> O Flex l√™ o arquivo caractere por caractere, tentando casar com os padr√µes definidos.
    </div>
    
    <div class="explicacao">
        <strong>2. Prioridade:</strong> Se m√∫ltiplos padr√µes casam, Flex escolhe o mais longo. Palavras-chave devem vir antes de identificadores gen√©ricos.
    </div>
    
    <div class="explicacao">
        <strong>3. A√ß√£o Executada:</strong> Quando um padr√£o casa, o c√≥digo C entre chaves √© executado.
    </div>
    
    <div class="explicacao">
        <strong>4. Vari√°veis Especiais:</strong><br>
        ‚Ä¢ <code>yytext</code> = string com o texto reconhecido<br>
        ‚Ä¢ <code>yylval</code> = union para armazenar valor do token<br>
        ‚Ä¢ <code>yylex()</code> = fun√ß√£o gerada que faz todo o trabalho
    </div>
    
    <h3>Exemplo Pr√°tico - Entrada vs Sa√≠da:</h3>
    <div class="exemplo">
        <strong>C√≥digo C- de entrada:</strong><br>
        <code>int x = 5;</code><br><br>
        
        <strong>Tokens gerados (sequ√™ncia):</strong>
        <pre>
Token 1: INT      (tipo: palavra-chave)
Token 2: ID       (valor: "x")
Token 3: ATRIBUICAO
Token 4: NUM      (valor: 5)
Token 5: PONTOVIRGULA
        </pre>
        
        <strong>Visualiza√ß√£o visual:</strong>
        <pre>
int     x     =     5     ;
‚îÇ       ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ
‚îî‚îÄINT   ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ
        ‚îî‚îÄID  ‚îÇ     ‚îÇ     ‚îÇ
              ‚îî‚îÄATR ‚îÇ     ‚îÇ
                    ‚îî‚îÄNUM ‚îÇ
                          ‚îî‚îÄPV
        </pre>
    </div>
    
    <h3>Como Compilar:</h3>
    <pre>
# Comando Flex para gerar o analisador l√©xico
flex cminus.l

# Resultado: arquivo lex.yy.c (c√≥digo C gerado automaticamente)
# Este arquivo cont√©m a fun√ß√£o yylex() que faz todo o reconhecimento
    </pre>
</div>

<div class="secao" id="tabela-simbolos">
    <h2>3. Tabela de S√≠mbolos (simbolos.h/c)</h2>
    
    <div class="arquivo">Arquivo: cminus.y</div>

    <div class="arquivo">Arquivos: simbolos.h, simbolos.c</div>
    
    <h3>O que faz?</h3>
    <p>Armazena informa√ß√µes sobre todos os <strong>identificadores</strong> (vari√°veis e fun√ß√µes) do programa. √â como um "dicion√°rio" que registra cada nome e seus atributos.</p>
    
    <div class="teoria">
        <strong>Teoria da Tabela de S√≠mbolos:</strong><br><br>
        A tabela de s√≠mbolos √© uma <strong>estrutura de dados fundamental</strong> em compiladores. Durante a compila√ß√£o, o compilador precisa:
        <br><br>
        1. <strong>Registrar</strong> quando uma vari√°vel √© declarada<br>
        2. <strong>Recuperar</strong> informa√ß√µes quando a vari√°vel √© usada<br>
        3. <strong>Validar</strong> se a vari√°vel foi declarada antes de usar<br>
        4. <strong>Rastrear</strong> o escopo (global vs local)<br>
        <br>
        A implementa√ß√£o mais comum √© uma <strong>lista ligada</strong> ou <strong>tabela hash</strong>. Nosso projeto usa lista ligada, onde cada novo s√≠mbolo √© inserido no in√≠cio.
    </div>
    
    <h3>Estrutura de Dados (simbolos.h):</h3>
    <pre>
typedef struct Simbolo {
    char nome[50];              /* Nome da vari√°vel ou fun√ß√£o */
    char tipo[10];              /* Tipo: "int", "void", "int[]" etc */
    char escopo[50];            /* "global" ou nome da fun√ß√£o onde est√° */
    int linha;                  /* Linha onde foi declarado (para erros) */
    int ehFuncao;               /* 1 = √© fun√ß√£o, 0 = √© vari√°vel */
    int numParametros;          /* N√∫mero de par√¢metros (se for fun√ß√£o) */
    struct Simbolo *prox;       /* Ponteiro para pr√≥ximo s√≠mbolo (lista ligada) */
} Simbolo;

/* Vari√°vel global que aponta para o in√≠cio da tabela */
static Simbolo *tabela = NULL;
    </pre>
    
    <h3>Explica√ß√£o de Cada Campo:</h3>
    <table>
        <tr>
            <th>Campo</th>
            <th>Tipo</th>
            <th>Descri√ß√£o</th>
            <th>Exemplo</th>
        </tr>
        <tr>
            <td><code>nome</code></td>
            <td>char[50]</td>
            <td>Nome do identificador</td>
            <td>"x", "main", "input"</td>
        </tr>
        <tr>
            <td><code>tipo</code></td>
            <td>char[10]</td>
            <td>Tipo de dado</td>
            <td>"int", "void", "int[]"</td>
        </tr>
        <tr>
            <td><code>escopo</code></td>
            <td>char[50]</td>
            <td>Onde est√° vis√≠vel</td>
            <td>"global" ou "main" (fun√ß√£o)</td>
        </tr>
        <tr>
            <td><code>linha</code></td>
            <td>int</td>
            <td>Linha de declara√ß√£o</td>
            <td>1, 5, 10</td>
        </tr>
        <tr>
            <td><code>ehFuncao</code></td>
            <td>int (bool)</td>
            <td>√â fun√ß√£o?</td>
            <td>1 = sim, 0 = n√£o</td>
        </tr>
        <tr>
            <td><code>numParametros</code></td>
            <td>int</td>
            <td>Quantidade de par√¢metros</td>
            <td>0, 1, 2...</td>
        </tr>
        <tr>
            <td><code>prox</code></td>
            <td>Simbolo*</td>
            <td>Pr√≥ximo n√≥ da lista</td>
            <td>Endere√ßo de mem√≥ria</td>
        </tr>
    </table>
    
    <h3>Fun√ß√µes Principais (simbolos.c):</h3>
    
    <h4>1. inserirSimbolo() - Adicionar novo s√≠mbolo</h4>
    <pre>
int inserirSimbolo(const char *nome, const char *tipo, 
                   const char *escopo, int linha, 
                   int ehFuncao, int numParams) {
    
    /* PASSO 1: Verifica se j√° existe no mesmo escopo
       Impede redeclara√ß√£o de vari√°veis no mesmo escopo */
    if (buscarSimboloNoEscopo(nome, escopo) != NULL) {
        return 0;  /* Retorna 0 = falha, s√≠mbolo j√° existe */
    }
    
    /* PASSO 2: Aloca mem√≥ria para novo s√≠mbolo
       malloc retorna um ponteiro para um bloco de mem√≥ria */
    Simbolo *novo = malloc(sizeof(Simbolo));
    
    /* PASSO 3: Copia dados para o novo s√≠mbolo
       strcpy = copia string de forma segura */
    strcpy(novo->nome, nome);
    strcpy(novo->tipo, tipo);
    strcpy(novo->escopo, escopo);
    novo->linha = linha;
    novo->ehFuncao = ehFuncao;
    novo->numParametros = numParams;
    
    /* PASSO 4: Insere no IN√çCIO da lista ligada
       Inserir no in√≠cio √© mais r√°pido que no final
       O novo s√≠mbolo aponta para o anterior, e ele vira o primeiro */
    novo->prox = tabela;   /* novo.prox aponta para o antigo primeiro */
    tabela = novo;          /* tabela agora aponta para o novo primeiro */
    
    return 1;  /* Retorna 1 = sucesso */
}
    </pre>
    
    <h4>2. buscarSimbolo() - Procurar por nome</h4>
    <pre>
Simbolo* buscarSimbolo(const char *nome, const char *escopo) {
    
    /* PASSO 1: Procura no escopo local (mais espec√≠fico) */
    Simbolo *s = buscarSimboloNoEscopo(nome, escopo);
    if (s != NULL) return s;  /* Encontrou! Retorna */
    
    /* PASSO 2: Se n√£o achou no local, procura no global
       Vari√°veis globais s√£o acess√≠veis de qualquer escopo */
    if (strcmp(escopo, "global") != 0) {  /* Se n√£o estamos j√° no global */
        s = buscarSimboloNoEscopo(nome, "global");
    }
    
    return s;  /* Retorna o s√≠mbolo ou NULL se n√£o existe */
}

/* Fun√ß√£o auxiliar que procura em um escopo espec√≠fico */
static Simbolo* buscarSimboloNoEscopo(const char *nome, 
                                      const char *escopo) {
    
    /* Percorre a lista ligada do in√≠cio at√© o fim */
    Simbolo *atual = tabela;
    
    while (atual != NULL) {
        /* Verifica se nome E escopo combinam
           strcmp retorna 0 se strings s√£o iguais */
        if (strcmp(atual->nome, nome) == 0 && 
            strcmp(atual->escopo, escopo) == 0) {
            
            return atual;  /* Encontrou! */
        }
        atual = atual->prox;  /* Move para pr√≥ximo s√≠mbolo */
    }
    
    return NULL;  /* N√£o encontrou */
}
    </pre>
    
    <h4>3. imprimirTabelaSimbolos() - Exibir tabela formatada</h4>
    <pre>
void imprimirTabelaSimbolos(void) {
    printf("\n");
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë             TABELA DE SIMBOLOS                                ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    /* Imprime cabe√ßalho da tabela com formata√ß√£o */
    printf("%-20s %-10s %-15s %-8s %-10s\n", 
           "Nome", "Tipo", "Escopo", "Linha", "Categoria");
    printf("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n");
    
    /* Percorre lista e imprime cada s√≠mbolo */
    Simbolo *atual = tabela;
    while (atual != NULL) {
        printf("%-20s %-10s %-15s %-8d %-10s\n",
               atual->nome,
               atual->tipo,
               atual->escopo,
               atual->linha,
               atual->ehFuncao ? "funcao" : "variavel");
        
        atual = atual->prox;  /* Pr√≥ximo s√≠mbolo */
    }
    printf("\n");
}
    </pre>
    
    <h3>Exemplo de Uso Pr√°tico:</h3>
    <div class="exemplo">
        <strong>C√≥digo C-:</strong>
        <pre>
int x;              /* Linha 1 */
int f(int y) {      /* Linha 3 */
    int z;          /* Linha 4 */
    x = y + z;      /* Linha 5 */
    return x;
}
void main(void) {   /* Linha 8 */
    f(5);
}
        </pre>
        
        <strong>Tabela de S√≠mbolos Resultante:</strong>
        <table>
            <tr>
                <th>Nome</th>
                <th>Tipo</th>
                <th>Escopo</th>
                <th>Linha</th>
                <th>Categoria</th>
            </tr>
            <tr>
                <td>x</td>
                <td>int</td>
                <td>global</td>
                <td>1</td>
                <td>variavel</td>
            </tr>
            <tr>
                <td>f</td>
                <td>int</td>
                <td>global</td>
                <td>3</td>
                <td>funcao</td>
            </tr>
            <tr>
                <td>y</td>
                <td>int</td>
                <td>f</td>
                <td>3</td>
                <td>variavel</td>
            </tr>
            <tr>
                <td>z</td>
                <td>int</td>
                <td>f</td>
                <td>4</td>
                <td>variavel</td>
            </tr>
            <tr>
                <td>main</td>
                <td>void</td>
                <td>global</td>
                <td>8</td>
                <td>funcao</td>
            </tr>
        </table>
        
        <strong>Como funciona a busca:</strong><br>
        Quando encontramos <code>x = y + z;</code> na linha 5:
        <ul>
            <li>Buscar <code>x</code>: primeiro no escopo "f", n√£o encontra ‚Üí busca em "global", encontra ‚úì</li>
            <li>Buscar <code>y</code>: no escopo "f", encontra ‚úì</li>
            <li>Buscar <code>z</code>: no escopo "f", encontra ‚úì</li>
        </ul>
    </div>
    
    <h3>Visualiza√ß√£o da Lista Ligada:</h3>
    <pre>
tabela ‚îÄ‚Üí [main|void|g|8] ‚îÄ‚îÄ‚Üí [z|int|f|4] ‚îÄ‚îÄ‚Üí [y|int|f|3] ‚îÄ‚îÄ‚Üí [f|int|g|3] ‚îÄ‚îÄ‚Üí [x|int|g|1] ‚îÄ‚îÄ‚Üí NULL
         (√∫ltimo inserido)                                                     (primeiro inserido)
         
Note: A ordem √© inversa da declara√ß√£o porque inserimos sempre no in√≠cio!
    </pre>
</div>
    
    <div class="exemplo">
        <strong>Exemplo:</strong><br>
        <strong>C√≥digo:</strong> <code>x = 5 + 3;</code><br><br>
        
        <strong>√Årvore gerada:</strong>
        <pre>
- ATRIB [linha 1]
  - ID (x) [linha 1]
  - SOMA (+) [linha 1]
    - NUM (5) [linha 1]
    - NUM (3) [linha 1]
        </pre>
    </div>
    
    <h3>Estrutura do arquivo cminus.y:</h3>
    <pre>
%{
/* SE√á√ÉO 1: C√≥digo C */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "arvore.h"
#include "simbolos.h"
#include "semantico.h"
#include "intermediario.h"

extern int yylex();
extern int linha;
NoArvore* raiz = NULL;

void yyerror(char *s) {
    fprintf(stderr, "ERRO SINTATICO: %s LINHA: %d\n", s, linha);
}
%}

/* SE√á√ÉO 2: Defini√ß√£o de tokens e tipos */
%union {
    void* no;
    char* str;
    int num;
}

%token &lt;str&gt; ID
%token &lt;num&gt; NUM
%token IF ELSE WHILE RETURN INT VOID
%token MAIS MENOS VEZES DIVIDIDO
%token ATRIBUICAO PONTOVIRGULA

%type &lt;no&gt; programa declaracao comando expressao

%%
/* SE√á√ÉO 3: Regras da gram√°tica */

programa:
    declaracao_lista
    { raiz = $1; }
    ;

declaracao:
    tipo ID PONTOVIRGULA
    { $$ = criarNo("VAR", $2, linha);
      adicionarFilho($$, $1); }
    ;

comando:
    ID ATRIBUICAO expressao PONTOVIRGULA
    { $$ = criarNo("ATRIB", NULL, linha);
      NoArvore* id = criarNo("ID", $1, linha);
      adicionarFilho($$, id);
      adicionarFilho($$, $3); }
    ;

expressao:
    expressao MAIS expressao
    { $$ = criarNo("SOMA", "+", linha);
      adicionarFilho($$, $1);
      adicionarFilho($$, $3); }
    | NUM
    { char numstr[16]; 
      sprintf(numstr, "%d", $1);
      $$ = criarNo("NUM", numstr, linha); }
    | ID
    { $$ = criarNo("ID", $1, linha); }
    ;

%%

int main(int argc, char *argv[]) {
    if (argc == 2) {
        FILE *fp = fopen(argv[1], "r");
        if (!fp) {
            printf("Erro ao abrir arquivo\n");
            return 1;
        }
        extern FILE *yyin;
        yyin = fp;
        
        yyparse();
        
        analisarSemantica(raiz);
        gerarCodigoIntermediario(raiz);
        
        imprimirArvore(raiz, 0);
        imprimirTabelaSimbolos();
        imprimirCodigoIntermediario();
        
        fclose(fp);
    }
    return 0;
}
    </pre>
    
    <h3>Como usar:</h3>
    <pre>
# Gerar o analisador sint√°tico
bison -d cminus.y

# Isso cria:
# - cminus.tab.c (c√≥digo do parser)
# - cminus.tab.h (defini√ß√µes de tokens)
    </pre>
</div>

<div class="secao">
    <h2>5. √Årvore Sint√°tica (arvore.h/c)</h2>
    
    <div class="arquivo">Arquivos: arvore.h, arvore.c</div>
    
    <h3>O que faz?</h3>
    <p>Representa a estrutura hier√°rquica do programa em forma de √°rvore.</p>
    
    <h3>Estrutura do N√≥ (arvore.h):</h3>
    <pre>
typedef struct noArvore {
    char tipo[20];              // Ex: "ATRIB", "SOMA", "ID"
    char valor[50];             // Ex: "x", "5", "+"
    int linha;                  // N√∫mero da linha no c√≥digo
    int nFilhos;                // Quantidade de filhos
    struct noArvore** filhos;   // Array de ponteiros para filhos
} NoArvore;
    </pre>
    
    <h3>Fun√ß√µes principais (arvore.c):</h3>
    <pre>
// Criar um novo n√≥
NoArvore* criarNo(const char* tipo, const char* valor, int linha) {
    NoArvore* no = malloc(sizeof(NoArvore));
    strcpy(no->tipo, tipo);
    if (valor) strcpy(no->valor, valor);
    no->linha = linha;
    no->nFilhos = 0;
    no->filhos = NULL;
    return no;
}

// Adicionar filho a um n√≥
void adicionarFilho(NoArvore* pai, NoArvore* filho) {
    pai->nFilhos++;
    pai->filhos = realloc(pai->filhos, 
                          sizeof(NoArvore*) * pai->nFilhos);
    pai->filhos[pai->nFilhos - 1] = filho;
}

// Imprimir a √°rvore com indenta√ß√£o
void imprimirArvore(NoArvore* no, int nivel) {
    if (!no) return;
    
    for (int i = 0; i < nivel; i++) printf("  ");
    printf("- %s", no->tipo);
    if (no->valor[0]) printf(" (%s)", no->valor);
    printf(" [linha %d]\n", no->linha);
    
    for (int i = 0; i < no->nFilhos; i++) {
        imprimirArvore(no->filhos[i], nivel + 1);
    }
}
    </pre>
    
    <div class="exemplo">
        <strong>Exemplo de sa√≠da:</strong>
        <pre>
- DECL_LIST [linha 3]
  - DECL [linha 1]
    - VAR (x) [linha 1]
      - TIPO (int) [linha 1]
  - DECL [linha 3]
    - FUN_DEF (main) [linha 3]
      - TIPO (void) [linha 3]
      - PARAMS (void) [linha 3]
      - CORPO [linha 5]
        - CMD [linha 4]
          - ATRIB [linha 4]
            - ID (x) [linha 4]
            - NUM (5) [linha 4]
        </pre>
    </div>
</div>

<div class="secao">
    <h2>6. Tabela de S√≠mbolos (simbolos.h/c)</h2>
    
    <div class="arquivo">Arquivos: simbolos.h, simbolos.c</div>
    
    <h3>O que faz?</h3>
    <p>Armazena informa√ß√µes sobre todos os <strong>identificadores</strong> (vari√°veis e fun√ß√µes) do programa.</p>
    
    <h3>Campos da tabela:</h3>
    <ul>
        <li><strong>Nome:</strong> nome da vari√°vel ou fun√ß√£o</li>
        <li><strong>Tipo:</strong> int, void, int[] (array)</li>
        <li><strong>Escopo:</strong> "global" ou nome da fun√ß√£o</li>
        <li><strong>Linha:</strong> linha onde foi declarado</li>
        <li><strong>Categoria:</strong> "variavel" ou "funcao"</li>
    </ul>
    
    <h3>Estrutura (simbolos.h):</h3>
    <pre>
typedef struct Simbolo {
    char nome[50];              // Nome do identificador
    char tipo[10];              // Tipo: "int", "void", "int[]"
    char escopo[50];            // Escopo: "global" ou nome da fun√ß√£o
    int linha;                  // Linha onde foi declarado
    int ehFuncao;               // 1 = fun√ß√£o, 0 = vari√°vel
    int numParametros;          // N√∫mero de par√¢metros (para fun√ß√µes)
    struct Simbolo *prox;       // Pr√≥ximo s√≠mbolo (lista ligada)
} Simbolo;
    </pre>
    
    <h3>Fun√ß√µes principais (simbolos.c):</h3>
    <pre>
// Inserir s√≠mbolo na tabela
int inserirSimbolo(const char *nome, const char *tipo, 
                   const char *escopo, int linha, 
                   int ehFuncao, int numParams) {
    // Verifica se j√° existe
    if (buscarSimboloNoEscopo(nome, escopo) != NULL) {
        return 0; // J√° existe
    }
    
    // Cria novo s√≠mbolo
    Simbolo *novo = malloc(sizeof(Simbolo));
    strcpy(novo->nome, nome);
    strcpy(novo->tipo, tipo);
    strcpy(novo->escopo, escopo);
    novo->linha = linha;
    novo->ehFuncao = ehFuncao;
    novo->numParametros = numParams;
    
    // Insere no in√≠cio da lista
    novo->prox = tabela;
    tabela = novo;
    
    return 1; // Sucesso
}

// Buscar s√≠mbolo (local primeiro, depois global)
Simbolo* buscarSimbolo(const char *nome, const char *escopo) {
    // Busca no escopo local
    Simbolo *s = buscarSimboloNoEscopo(nome, escopo);
    if (s) return s;
    
    // Se n√£o achou, busca no global
    if (strcmp(escopo, "global") != 0) {
        s = buscarSimboloNoEscopo(nome, "global");
    }
    
    return s;
}

// Imprimir tabela formatada
void imprimirTabelaSimbolos(void) {
    printf("\n=== TABELA DE SIMBOLOS ===\n");
    printf("%-20s %-10s %-15s %-8s %-10s\n", 
           "Nome", "Tipo", "Escopo", "Linha", "Categoria");
    printf("--------------------------------------------------------\n");
    
    Simbolo *atual = tabela;
    while (atual != NULL) {
        printf("%-20s %-10s %-15s %-8d %-10s\n",
               atual->nome, atual->tipo, atual->escopo,
               atual->linha, 
               atual->ehFuncao ? "funcao" : "variavel");
        atual = atual->prox;
    }
}
    </pre>
    
    <div class="exemplo">
        <strong>Exemplo de sa√≠da:</strong>
        <table>
            <tr>
                <th>Nome</th>
                <th>Tipo</th>
                <th>Escopo</th>
                <th>Linha</th>
                <th>Categoria</th>
            </tr>
            <tr>
                <td>x</td>
                <td>int</td>
                <td>global</td>
                <td>1</td>
                <td>variavel</td>
            </tr>
            <tr>
                <td>main</td>
                <td>void</td>
                <td>global</td>
                <td>3</td>
                <td>funcao</td>
            </tr>
            <tr>
                <td>a</td>
                <td>int</td>
                <td>main</td>
                <td>4</td>
                <td>variavel</td>
            </tr>
        </table>
    </div>
</div>

<div class="secao">
    <h2>7. An√°lise Sem√¢ntica (semantico.h/c)</h2>
    
    <div class="arquivo">Arquivos: semantico.h, semantico.c</div>
    
    <h3>O que faz?</h3>
    <p>Verifica <strong>regras sem√¢nticas</strong> da linguagem:</p>
    <ul>
        <li>Vari√°veis devem ser declaradas antes do uso</li>
        <li>Tipos devem ser compat√≠veis em atribui√ß√µes</li>
        <li>Fun√ß√£o <code>main</code> √© obrigat√≥ria</li>
        <li>N√£o pode haver redeclara√ß√£o de vari√°veis no mesmo escopo</li>
    </ul>
    
    <h3>Fun√ß√£o principal (semantico.c):</h3>
    <pre>
int analisarSemantica(NoArvore *raiz) {
    errosSemanticos = 0;
    
    // Inicializa fun√ß√µes predefinidas
    inserirSimbolo("input", "int", "global", 0, 1, 0);
    inserirSimbolo("output", "void", "global", 0, 1, 1);
    
    // Percorre a √°rvore
    if (raiz != NULL) {
        analisarNo(raiz);
    }
    
    // Verifica se main() existe
    if (buscarSimbolo("main", "global") == NULL) {
        printf("ERRO SEMANTICO: funcao 'main' nao declarada\n");
        errosSemanticos++;
    }
    
    return errosSemanticos;
}

static void analisarNo(NoArvore *no) {
    if (no == NULL) return;
    
    // DECLARA√á√ÉO DE VARI√ÅVEL
    if (strcmp(no->tipo, "VAR") == 0) {
        // Extrai tipo e nome
        char tipo[20];
        strcpy(tipo, no->filhos[0]->valor); // "int" ou "void"
        char *nome = no->valor;
        
        // Insere na tabela
        if (!inserirSimbolo(nome, tipo, escopoAtual, 
                            no->linha, 0, 0)) {
            printf("ERRO SEMANTICO: variavel '%s' ja declarada\n", 
                   nome);
            errosSemanticos++;
        }
    }
    
    // USO DE VARI√ÅVEL
    else if (strcmp(no->tipo, "ID") == 0) {
        Simbolo *s = buscarSimbolo(no->valor, escopoAtual);
        if (s == NULL) {
            printf("ERRO SEMANTICO: variavel '%s' nao declarada LINHA: %d\n",
                   no->valor, no->linha);
            errosSemanticos++;
        }
    }
    
    // Percorre filhos
    for (int i = 0; i < no->nFilhos; i++) {
        analisarNo(no->filhos[i]);
    }
}
    </pre>
    
    <div class="exemplo">
        <strong>Exemplos de erros detectados:</strong>
        <pre>
ERRO SEMANTICO: variavel 'y' nao declarada LINHA: 10
ERRO SEMANTICO: variavel 'x' ja declarada neste escopo LINHA: 12
ERRO SEMANTICO: funcao 'main' nao declarada LINHA: 0
ERRO SEMANTICO: atribuicao de tipo incompat√≠vel ('int' = 'void') LINHA: 15
        </pre>
    </div>
</div>

<div class="secao">
    <h2>8. C√≥digo Intermedi√°rio (intermediario.h/c)</h2>
    
    <div class="arquivo">Arquivos: intermediario.h, intermediario.c</div>
    
    <h3>O que faz?</h3>
    <p>Converte a √°rvore sint√°tica em <strong>c√≥digo de 3 endere√ßos</strong> (tr√™s-address code), uma representa√ß√£o intermedi√°ria mais simples que facilita otimiza√ß√µes e a gera√ß√£o de c√≥digo final.</p>
    
    <h3>Estrutura (intermediario.h):</h3>
    <pre>
typedef struct {
    int numero;             // N√∫mero da instru√ß√£o
    char operador[10];      // Operador: +, -, *, /, =, etc.
    char operando1[50];     // Primeiro operando
    char operando2[50];     // Segundo operando (pode estar vazio)
    char resultado[50];     // Resultado (vari√°vel tempor√°ria ou destino)
} Instrucao3Endereco;
    </pre>
    
    <div class="exemplo">
        <strong>Exemplo de convers√£o:</strong><br><br>
        
        <strong>C√≥digo C-:</strong><br>
        <code>x = y + z * 2;</code><br><br>
        
        <strong>C√≥digo intermedi√°rio gerado:</strong>
        <table>
            <tr>
                <th>Num</th>
                <th>Op</th>
                <th>Operando1</th>
                <th>Operando2</th>
                <th>Resultado</th>
            </tr>
            <tr>
                <td>1</td>
                <td>*</td>
                <td>z</td>
                <td>2</td>
                <td>t0</td>
            </tr>
            <tr>
                <td>2</td>
                <td>+</td>
                <td>y</td>
                <td>t0</td>
                <td>t1</td>
            </tr>
            <tr>
                <td>3</td>
                <td>=</td>
                <td>t1</td>
                <td></td>
                <td>x</td>
            </tr>
        </table>
    </div>
    
    <h3>Fun√ß√£o principal (intermediario.c):</h3>
    <pre>
int gerarCodigoIntermediario(NoArvore *raiz) {
    totalInstrucoes = 0;
    contadorTemp = 0;
    
    instrucoes = malloc(sizeof(Instrucao3Endereco) * 100);
    
    char resultado[50];
    analisarNoIntermediario(raiz, resultado);
    
    return totalInstrucoes;
}

static void analisarNoIntermediario(NoArvore *no, char *resultado) {
    if (no == NULL) return;
    
    // OPERA√á√ïES BIN√ÅRIAS
    if (strcmp(no->tipo, "SOMA") == 0) {
        char temp1[50], temp2[50];
        
        // Gera c√≥digo para operando 1
        analisarNoIntermediario(no->filhos[0], temp1);
        
        // Gera c√≥digo para operando 2
        analisarNoIntermediario(no->filhos[1], temp2);
        
        // Gera instru√ß√£o de soma
        char *temp = gerarTemp(); // ex: "t0"
        gerarInstrucao("+", temp1, temp2, temp);
        strcpy(resultado, temp);
    }
    
    // ATRIBUI√á√ÉO
    else if (strcmp(no->tipo, "ATRIB") == 0) {
        char tempdireito[50];
        
        // Processa lado direito
        analisarNoIntermediario(no->filhos[1], tempdireito);
        
        // Atribui ao lado esquerdo
        char *nome = no->filhos[0]->valor;
        gerarInstrucao("=", tempdireito, "", nome);
    }
    
    // N√öMERO ou IDENTIFICADOR
    else if (strcmp(no->tipo, "NUM") == 0 || 
             strcmp(no->tipo, "ID") == 0) {
        strcpy(resultado, no->valor);
    }
}
    </pre>
</div>

<div class="secao">
    <h2>9. Compilando e Executando</h2>
    
    <h3>Passo 1: Gerar os arquivos com Flex e Bison</h3>
    <pre>
flex cminus.l          # Gera lex.yy.c
bison -d cminus.y      # Gera cminus.tab.c e cminus.tab.h
    </pre>
    
    <h3>Passo 2: Compilar tudo com GCC</h3>
    <pre>
gcc lex.yy.c cminus.tab.c arvore.c simbolos.c semantico.c intermediario.c -o scanner.exe
    </pre>
    
    <h3>Passo 3: Executar com arquivo de teste</h3>
    <pre>
./scanner.exe teste1_basico.cm
    </pre>
    
    <h3>Sa√≠da esperada:</h3>
    <pre>
=== COMPILADOR C- ===

Analisando arquivo: teste1_basico.cm

--- FASE 1: ANALISE SINTATICA ---
Analise sintatica concluida com sucesso!

--- FASE 2: ANALISE SEMANTICA ---
Analise semantica concluida sem erros!

--- ARVORE SINTATICA ---
- DECL_LIST [linha 5]
  - DECL [linha 1]
    - VAR (x) [linha 1]
      - TIPO (int) [linha 1]
  - DECL [linha 5]
    - FUN_DEF (main) [linha 5]
      ...

--- FASE 3: GERACAO DE CODIGO INTERMEDIARIO ---
Codigo intermediario gerado: 2 instrucoes

=== CODIGO INTERMEDIARIO (3-ADDRESS CODE) ===
Num      Op         Operando1       Operando2       Resultado
1        +          y               1               t0
2        =          t0                              x

=== TABELA DE SIMBOLOS ===
Nome                 Tipo       Escopo          Linha    Categoria
x                    int        global          1        variavel
main                 void       global          5        funcao
    </pre>
</div>

<div class="secao">
    <h2>10. Arquivos de Teste</h2>
    
    <h3>teste1_basico.cm - Teste b√°sico</h3>
    <pre>
int x;

void main(void) {
    x = 5;
    return 0;
}
    </pre>
    
    <h3>teste3_erros_semanticos.cm - Teste de erros sem√¢nticos</h3>
    <pre>
int x;

void main(void) {
    int a;
    a = 5;
    x = y + 1;      /* Erro: y n√£o declarada */
    z = a;          /* Erro: z n√£o declarada */
    return 0;
}
    </pre>
    
    <h3>teste4_sem_main.cm - Teste sem fun√ß√£o main</h3>
    <pre>
int x;

int outra(void) {
    x = 5;
    return x;
}
/* Erro: falta a fun√ß√£o main */
    </pre>
    
    <h3>teste6_tipos.cm - Teste de tipos</h3>
    <pre>
int x;
int y;

int f(void) { 
    return 1;
}

void g(void) { 
}

void main(void) {
    x = y + 1;
    x = y + z;      /* Erro: z n√£o declarada */
    return 0;
}
    </pre>
</div>

<div class="secao">
    <h2>11. Comandos Resumidos</h2>
    
    <table>
        <tr>
            <th>Comando</th>
            <th>Descri√ß√£o</th>
        </tr>
        <tr>
            <td><code>flex cminus.l</code></td>
            <td>Gera o analisador l√©xico (lex.yy.c)</td>
        </tr>
        <tr>
            <td><code>bison -d cminus.y</code></td>
            <td>Gera o analisador sint√°tico (cminus.tab.c/h)</td>
        </tr>
        <tr>
            <td><code>gcc lex.yy.c cminus.tab.c arvore.c simbolos.c semantico.c intermediario.c -o scanner.exe</code></td>
            <td>Compila todos os arquivos</td>
        </tr>
        <tr>
            <td><code>./scanner.exe arquivo.cm</code></td>
            <td>Executa o compilador</td>
        </tr>
        <tr>
            <td><code>git add .</code></td>
            <td>Adiciona arquivos ao Git</td>
        </tr>
        <tr>
            <td><code>git commit -m "mensagem"</code></td>
            <td>Faz commit das altera√ß√µes</td>
        </tr>
        <tr>
            <td><code>git push origin main</code></td>
            <td>Envia para o GitHub</td>
        </tr>
    </table>
</div>

<div class="secao">
    <h2>12. Gloss√°rio de Termos</h2>
    
    <ul>
        <li><strong>Token:</strong> Unidade l√©xica b√°sica (palavra-chave, identificador, operador)</li>
        <li><strong>Gram√°tica:</strong> Conjunto de regras que definem a sintaxe da linguagem</li>
        <li><strong>√Årvore Sint√°tica (AST):</strong> Representa√ß√£o hier√°rquica da estrutura do programa</li>
        <li><strong>Escopo:</strong> Regi√£o do c√≥digo onde uma vari√°vel √© vis√≠vel</li>
        <li><strong>Tipo:</strong> Classifica√ß√£o de dados (int, void, array)</li>
        <li><strong>C√≥digo de 3 endere√ßos:</strong> Forma intermedi√°ria onde cada instru√ß√£o tem no m√°ximo 3 operandos</li>
        <li><strong>Vari√°vel tempor√°ria:</strong> Vari√°vel auxiliar criada durante a gera√ß√£o de c√≥digo (t0, t1, etc.)</li>
        <li><strong>An√°lise sem√¢ntica:</strong> Verifica√ß√£o de significado e regras da linguagem</li>
    </ul>
</div>

<div class="secao">
    <h2>13. Resumo das Fases</h2>
    
    <table>
        <tr>
            <th>Fase</th>
            <th>Entrada</th>
            <th>Sa√≠da</th>
            <th>Arquivo</th>
        </tr>
        <tr>
            <td>1. An√°lise L√©xica</td>
            <td>C√≥digo-fonte (.cm)</td>
            <td>Tokens</td>
            <td>cminus.l</td>
        </tr>
        <tr>
            <td>2. An√°lise Sint√°tica</td>
            <td>Tokens</td>
            <td>√Årvore Sint√°tica</td>
            <td>cminus.y</td>
        </tr>
        <tr>
            <td>3. An√°lise Sem√¢ntica</td>
            <td>√Årvore Sint√°tica</td>
            <td>Tabela de S√≠mbolos + Erros</td>
            <td>semantico.c</td>
        </tr>
        <tr>
            <td>4. C√≥digo Intermedi√°rio</td>
            <td>√Årvore Sint√°tica</td>
            <td>Instru√ß√µes de 3 endere√ßos</td>
            <td>intermediario.c</td>
        </tr>
    </table>
</div>

<p style="text-align: center; margin-top: 40px; color: #7f8c8d;">
    <strong>Compilador C- - Projeto Final de Compiladores</strong><br>
    Desenvolvido com Flex, Bison e C
</p>

</body>
</html>